---
title: "Announcing Jco 1.0"
author: "Yosh Wuyts"
date: "2024-02-19"
github_name: "yoshuawuyts"
excerpt_separator: <!--end_excerpt-->
---

We’re happy to announce the 1.0.0 release of [jco]: a native Javascript runtime to
run WASI 0.2.0 components in. Being 1.0.0 means jco is now considered stable,
and at least for the foreseeable future will not be making breaking changes. It
can natively run WASI components inside of Node.js, making it easier to combine
components written in different programming languages with the Node.js runtime.
Providing those components access to networking, filesystem, and other system
APIs available in the Node.js runtime.

Work for support of WASI targeting the browser is still in-progress, but it can
already be used experimentally. Not all APIs available on operating system
targets can be made available to browsers. So you can expect a subset of the
portable WASI:CLI world to be available in the browser. However, work is also
ongoing to develop a browser-native WASI target in order to expose the full
breadth of features. Once the browser target stabilizes we’ll be able to discuss
that in more detail.

Finally, jco can also be used to take JavaScript code, and compile it to a WASI
0.2.0 component. This is enabled by compiling the Spidermonkey JavaScript
runtime to WebAssembly, and using it to execute JavaScript with. See the
componentize-js project for more details.

## Example

To give you a taste of what it's like to use jco, let’s compile a little Rust
program to a WASI 0.2.0 component, install jco for Node.js, and then embed the
newly built component inside of the runtime. If you want to skip ahead to the
final result, you can view it here.

### Dependencies and Repository

Because we're going to be writing Rust code, and using it from Node.js we expect
you to have both a working [Node.js environment](https://github.com/nvm-sh/nvm)
and [Rust toolchain](https://rustup.rs) installed. Once you have that, we can
install [`cargo-component`](https://github.com/bytecodealliance/cargo-component)
to build our Rust code, and [jco] to build it for Node.js.

```bash
$ npm install -g @bytecodealliance/jco  # install the jco cli tool
$ cargo install cargo-component         # install the `cargo component` subcommand
```

We can then proceed to create a new project repository, which has both Rust and JS code:

```sh
$ cargo component new playground-jco --lib # create a new Rust component
$ cd playground-jco                        # enter the newly created project
$ npm init -y                              # setup a Node.js environment
$ touch index.js                           # create a JS entrypoint
$ echo node_modules >> .gitignore          # add node_modules to our .gitignore file
```

This should leave you with a structure that roughly looks like this:

```bash
src/lib.rs                  # Our Rust library entry point
wit/world.wit               # Contains our WIT IDL definitions
Cargo.toml                  # Configures our Rust project
index.js                    # Our JS binary entry point
package.json                # Configures our JS Project
```

And with that out of the way, we're ready to begin writing some code!

### Defining the WIT interface

There are three steps to this project: defining the WIT interface, writing the
Rust code to be exported, and writing the JS code to be imported. We'll be
starting with the WIT interface. For those of you new to Wasm Components: WIT is
an Interface Definition Language (IDL) which allows you to describe programming
interfaces in a declarative, language agnostic way. Let's define an interface
which takes a string, and converts it to [SCREAMING_SNAKE_CASE](https://docs.rs/convert_case/latest/convert_case/enum.Case.html#variant.ScreamingSnake).

```wit
package my-org:wit-playground

world playground {
  export scream: func(input: string) -> string;
}
```

We can save this to the generated `wit/world.wit` file [^cc-gen], and now we have defined
a function `scream` which takes a string, and returns a string. And with that,
it's time to write our Rust code!

[^cc-gen]: If you're from the future: `cargo-component` generated.

### Defining the Rust library

As mentioned, we're using the `cargo-component` tool here in this example to
compile our Rust code to Wasm Components. It isn't yet at 1.0, but it *does*
work pretty well. So we'll show you how you can use it today. If you're from the
future (e.g. not February 2024), please check the `cargo-component` docs to see
how to follow these steps. Roughly speaking what we're going to do is: take
`.wit` definitions in, produce Rust code out. And then fill out the
implementations. Even in the future there should be a way to do that.

First things first: we want `cargo component` to generate the bindings for our
WIT file. This is done via Rust traits, and it will do this automatically when
we compile. This will yield a compiler error, but that's okay - we'll update the code in a second:

```bash
$ cargo component check
```

This will have generated Rust bindings, which on the current version of
`cargo-component` is places under `lib/bindings.rs`. Don't worry about reading
that code right now - it does a lot of heavy lifting so we don't have to. The
important part is that it provides us with traits which we can implement. So let's implement those in our code, and write a little upper case function

```rust
mod bindings;                                     // teach our program about `src/bindings.rs`

use bindings::Guest;                              // import the trait repr of our WIT world
use wit_bindgen::rt::string::String as WitString; // import the WIT string type

struct Component;                                 // define the type to export
impl Guest for Component {                        // import the WIT world + methods
    fn scream(input: WitString) -> WitString {
        input.to_uppercase().replace(' ', "_").into()
    }
}
```

Now if we re-run `cargo component check`, it should compile without any warnings. That means we're ready to run:

```bash
$ cargo component build      # Compile our Rust library to a Wasm Component
```

### Defining the JS binary


## Conclusion

In this post we’ve introduce jco 1.0.0: a native JavaScript runtime which can
run WASI 0.2.0 components. We’ve discussed what has been stabilized, which
features are currently in progress, as well as future directions. Finally we’ve
shown an example of how to use jco to embed a Rust library inside of a Node.js
project.

TODO: mention async and the Rust ecosystem not being ready yet. As well as other
language toolchains still being in-progress.

Jco is a Bytecode Alliance project, designed and led by Guy Bedford (Fastly).
The 1.0.0 release of Jco was made possible with the assistance of Pat Hickey
(Fastly), Wassim Chegham (Microsoft), Dirk Bäumer (Microsoft), and Yosh Wuyts
(Microsoft). On behalf of the Bytecode Alliance, we’d like to thank everyone who
was involved with the conception, design, and development of jco. And we’re very
excited for people to be able to start using it in their projects!

[jco]: https://github.com/bytecodealliance/jco
